use std::str::FromStr;
use g::G;
use ghost::Ghost;
use v::V;
use int_seq::IntSeq;
use compilation_error::CompErr;
use compilation_error::pe;
use std::vec::Vec;
use ranged_serializers::unescape_character;
use parser_state::ParserState;
use lalrpop_util::ParseError;

grammar(ghost:&Ghost, state:&mut ParserState);

match {
    "/",
    "!!",
    "=",
    "*",
    "+",
    "?",
    ":",
    "(",
    ")",
    "|",
    r"[#.a-zA-Zα-ωΑ-Ω∅_][#.a-zA-Zα-ωΑ-Ω∅_0-9]*" => ID_TOKEN,
    r"[0-9]+" => NUM_TOKEN,
    r"'([^\n\r\\']|\\.)*'" => STR_TOKEN,
    r#""([^\n\r\\"]|\\.)*""# => D_STR_TOKEN,
    r"\[((\\.|[^\[\]\\-])-(\\.|[^\[\]\\-])|(\\.|[^\[\]\\-]))*\]" => RANGE_TOKEN,
    r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },  // Skip `/* comments */`
}

extern {
    type Error = CompErr;
}



pub Funcs: () = {
    <Statement*>
};

Statement: () = {
    "/" <exponential:"!!"?> <id:ID> "=" <g:MealyUnion> =>? pe(state.introduce_variable(id,V::UNKNOWN,exponential.is_some(),g)),
};

pub MealyUnion: G = {
    <n:MealyConcat> <v:("|" <MealyConcat> )*>  =>? pe(v.into_iter().try_fold(n,|lhs,rhs|lhs.union(rhs,V::UNKNOWN,ghost))),
};

MealyConcat: G = {
    <n:MealyKleeneClosure> <v:MealyKleeneClosure*>  => v.into_iter().fold(n,|lhs,rhs|lhs.concat(rhs,ghost)),
};

MealyKleeneClosure: G = {
    <n:MealyAtomic> "*" =>? pe(n.kleene(V::UNKNOWN, ghost)),
    <n:MealyAtomic> "+" =>? pe(n.kleene_semigroup(V::UNKNOWN, ghost)),
    <n:MealyAtomic> "?" =>? pe(n.kleene_optional(V::UNKNOWN, ghost)),
    <MealyAtomic>
};

MealyAtomic:G = {
    <s:StringLiteral> => G::new_from_string(s.chars().map(|x| x as u32),V::UNKNOWN,ghost),
    <s:DoubleQuotedStringLiteral> => G::new_from_reflected_string(s.chars().map(|x| x as u32),V::UNKNOWN,ghost),
    <Range>,
    <exponential:"!!"?> <id:ID> =>? if exponential.is_some(){state.copy_variable(&id,ghost)}else{state.consume_variable(id.clone(),ghost)}.map(|e|e.2).ok_or(ParseError::User{error:CompErr::UndefinedFunction(V::UNKNOWN,id)}),
    ":" <s:StringLiteral> => G::new_from_output_string(IntSeq::from(s)),
    "(" <MealyUnion> ")"
};

ID: String = <s:ID_TOKEN> => String::from(s);
Weight: i32 = <s:NUM_TOKEN> => i32::from_str(s).unwrap();
StringLiteral: &'input str = <s:STR_TOKEN> => &s[1..s.len()-1];
DoubleQuotedStringLiteral: &'input str = <s:D_STR_TOKEN> => &s[1..s.len()-1];
Range:G = <s:RANGE_TOKEN> =>? {
    let mut ranges = Vec::<(u32,u32)>::new();
    let codepoints:Vec<char> = s[1..s.len()].chars().collect();
    let mut i = 0;
    while i < codepoints.len()-1{
        let from = if codepoints[i] == '\\'{
            i+=1;
            unescape_character(codepoints[i])
        }else{
            codepoints[i]
        };
        let to = if codepoints[i+1] == '-'{
            i+=2;
            if codepoints[i] == '\\'{
                i+=1;
                unescape_character(codepoints[i])
            }else{
                codepoints[i]
            }
        }else{
            from
        };
        i+=1;
        let from = from as u32;
        let to = to as u32;
        if from==0{
            return Err(ParseError::User{error:CompErr::Parse(V::UNKNOWN,String::from("Null symbol \\0 is not allowed on input"))});
        }
        ranges.push((from-1,to));
    }
    Ok(G::new_from_ranges(ranges.iter().cloned(),V::UNKNOWN,ghost))
};
